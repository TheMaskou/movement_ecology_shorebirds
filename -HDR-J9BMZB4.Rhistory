purrr::map(~ make_plot(.x[[1]], .x[[2]]))
plots_used_rate[[1]]
plots_used_rate[[2]]
# Tide and species groupings
tide_levels <- c("Low", "High")
species_types <- unique(shorebird_class)
# Function to generate a plot for a given combination
make_plot <- function(tide_level, species_type, min_n_nonzero = 2) {
data_sub <- figure_plot %>%
filter(tideHighLow == tide_level) %>%
mutate(species_class = shorebird_class[speciesEN]) %>%
filter(species_class == species_type) %>%
group_by(recvDeployName, tideDiel) %>%
mutate(n_nonzero = sum(rate_use > 0),
n_samples = n()) %>%
ungroup()
p <- ggplot(data_sub,
aes(x    = factor(recvDeployName, levels = sort(unique(recvDeployName))),
y    = rate_use,
fill = tideDiel))
# Only add boxplot if there are enough non-zero values in each group
data_for_boxplot <- data_sub %>%
filter(n_nonzero >= min_n_nonzero)
# Create fake data for missing tideDiel categories to maintain boxplot spacing
all_combinations <- expand.grid(
recvDeployName = unique(data_sub$recvDeployName),
tideDiel = c("Diurnal", "Nocturnal"),
speciesEN = unique(data_sub$speciesEN),
stringsAsFactors = FALSE
)
existing_combinations <- data_for_boxplot %>%
distinct(recvDeployName, tideDiel, speciesEN)
missing_combinations <- all_combinations %>%
anti_join(existing_combinations, by = c("recvDeployName", "tideDiel", "speciesEN"))
# Create transparent fake data
if (nrow(missing_combinations) > 0) {
fake_data <- missing_combinations %>%
mutate(rate_use = 0,
n_nonzero = 0,
n_samples = 0,
is_fake = TRUE)
data_for_boxplot <- data_for_boxplot %>%
mutate(is_fake = FALSE) %>%
bind_rows(fake_data)
} else {
data_for_boxplot <- data_for_boxplot %>%
mutate(is_fake = FALSE)
}
if (nrow(data_for_boxplot) > 0) {
p <- p + geom_boxplot(data = data_for_boxplot,
aes(alpha = ifelse(is_fake, 0, 1)),
outlier.shape = NA,
varwidth = FALSE,
position = position_dodge(width = 0.8, preserve = "single")) +
scale_alpha_identity()
}
# Always show individual points for ALL data
p <- p +
geom_point(aes(shape = tideDiel, fill = tideDiel),
position = position_dodge(width = 0.8),
alpha = 1, size = 1.5,
show.legend = FALSE) +
scale_shape_manual(values = c("Diurnal" = 21, "Nocturnal" = 16)) +
scale_fill_manual(values = c("Diurnal" = "white", "Nocturnal" = "black")) +
facet_wrap(~ speciesEN,
labeller = labeller(speciesEN = label_vec)) +
labs(x     = "Receiver Deployment",
y     = "Rate of Use (%)",
fill  = "Tide Diel",
title = paste(ifelse(species_type == "migratory",
"Migratory species", "Resident species"),
"during", tide_level, "tide")) +
coord_cartesian(ylim = c(0, 100)) +
theme_minimal() +
scale_fill_manual(values = c("Diurnal" = "white", "Nocturnal" = "darkgrey")) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
return(p)
}
# Generate and store all plots in a list
plots_used_rate <- cross2(tide_levels, species_types) %>%
purrr::map(~ make_plot(.x[[1]], .x[[2]]))
plots_used_rate[[4]]
# Tide and species groupings
tide_levels <- c("Low", "High")
species_types <- unique(shorebird_class)
# Function to generate a plot for a given combination
make_plot <- function(tide_level, species_type, min_n_nonzero = 2) {
data_sub <- figure_plot %>%
filter(tideHighLow == tide_level) %>%
mutate(species_class = shorebird_class[speciesEN]) %>%
filter(species_class == species_type) %>%
group_by(recvDeployName, tideDiel) %>%
mutate(n_nonzero = sum(rate_use > 0),
n_samples = n()) %>%
ungroup()
p <- ggplot(data_sub,
aes(x    = factor(recvDeployName, levels = sort(unique(recvDeployName))),
y    = rate_use,
fill = tideDiel))
# Only add boxplot if there are enough non-zero values in each group
data_for_boxplot <- data_sub %>%
filter(n_nonzero >= min_n_nonzero)
# Create fake data for missing tideDiel categories to maintain boxplot spacing
all_combinations <- expand.grid(
recvDeployName = unique(data_sub$recvDeployName),
tideDiel = c("Diurnal", "Nocturnal"),
speciesEN = unique(data_sub$speciesEN),
stringsAsFactors = FALSE
)
existing_combinations <- data_for_boxplot %>%
distinct(recvDeployName, tideDiel, speciesEN)
missing_combinations <- all_combinations %>%
anti_join(existing_combinations, by = c("recvDeployName", "tideDiel", "speciesEN"))
# Create transparent fake data
if (nrow(missing_combinations) > 0) {
fake_data <- missing_combinations %>%
mutate(rate_use = 0,
n_nonzero = 0,
n_samples = 0,
is_fake = TRUE)
data_for_boxplot <- data_for_boxplot %>%
mutate(is_fake = FALSE) %>%
bind_rows(fake_data)
} else {
data_for_boxplot <- data_for_boxplot %>%
mutate(is_fake = FALSE)
}
if (nrow(data_for_boxplot) > 0) {
p <- p + geom_boxplot(data = data_for_boxplot,
aes(alpha = ifelse(is_fake, 0, 1)),
outlier.shape = NA,
varwidth = FALSE,
position = position_dodge(width = 0.8, preserve = "single")) +
scale_alpha_identity()
}
# Always show individual points for ALL data
p <- p +
geom_point(aes(shape = tideDiel, fill = tideDiel),
position = position_dodge(width = 0.8),
alpha = 1, size = 1.5,
show.legend = FALSE) +
scale_shape_manual(values = c("Diurnal" = 21, "Nocturnal" = 16)) +
scale_fill_manual(values = c("Diurnal" = "white", "Nocturnal" = "black")) +
facet_wrap(~ speciesEN,
labeller = labeller(speciesEN = label_vec)) +
labs(x     = "Receiver Deployment",
y     = "Rate of Use (%)",
fill  = "Tide Diel",
title = paste(ifelse(species_type == "migratory",
"Migratory species", "Resident species"),
"during", tide_level, "tide")) +
coord_cartesian(ylim = c(0, 50)) +
theme_minimal() +
scale_fill_manual(values = c("Diurnal" = "white", "Nocturnal" = "darkgrey")) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
return(p)
}
# Generate and store all plots in a list
plots_used_rate <- cross2(tide_levels, species_types) %>%
purrr::map(~ make_plot(.x[[1]], .x[[2]]))
plots_used_rate[[4]]
plots_used_rate[[3]]
plots_used_rate[[2]]
plots_used_rate[[1]]
make_plot <- function(species_name, recv_order, min_n_nonzero = 2) {
data_sub <- figure_plot %>%
filter(speciesEN == species_name) %>%
group_by(recvDeployName, tideDiel, tideHighLow) %>%
mutate(n_nonzero = sum(rate_use > 0),
n_samples = n()) %>%
ungroup()
p <- ggplot(data_sub,
aes(x    = factor(recvDeployName, levels = recv_order),
y    = rate_use,
fill = tideDiel))
# Only add boxplot if there are enough non-zero values in each group
data_for_boxplot <- data_sub %>%
filter(n_nonzero >= min_n_nonzero)
# Identify recvDeployName Ã— tideHighLow combinations that have at least some data
locations_with_data <- data_for_boxplot %>%
group_by(recvDeployName, tideHighLow) %>%
summarise(has_data = n() > 0, .groups = "drop") %>%
filter(has_data)
# Create fake data only for tideDiel categories that are missing
# BUT only for locations that have at least some data
all_combinations <- locations_with_data %>%
select(recvDeployName, tideHighLow) %>%
cross_join(data.frame(tideDiel = c("Diurnal", "Nocturnal")))
existing_combinations <- data_for_boxplot %>%
distinct(recvDeployName, tideDiel, tideHighLow)
missing_combinations <- all_combinations %>%
anti_join(existing_combinations, by = c("recvDeployName", "tideDiel", "tideHighLow"))
# Create transparent fake data
if (nrow(missing_combinations) > 0) {
fake_data <- missing_combinations %>%
mutate(rate_use = 0,
n_nonzero = 0,
n_samples = 0,
is_fake = TRUE,
speciesEN = species_name)
data_for_boxplot <- data_for_boxplot %>%
mutate(is_fake = FALSE) %>%
bind_rows(fake_data)
} else {
data_for_boxplot <- data_for_boxplot %>%
mutate(is_fake = FALSE)
}
if (nrow(data_for_boxplot) > 0) {
p <- p + geom_boxplot(data = data_for_boxplot,
aes(alpha = ifelse(is_fake, 0, 1)),
outlier.shape = NA,
varwidth = FALSE,
position = position_dodge(width = 0.8, preserve = "single")) +
scale_alpha_identity()
}
# Always show individual points for ALL data
p <- p +
geom_point(aes(shape = tideDiel, fill = tideDiel),
position = position_dodge(width = 0.8),
alpha = 1, size = 1.5,
show.legend = TRUE) +
scale_shape_manual(values = c("Diurnal" = 21, "Nocturnal" = 16)) +
scale_fill_manual(values = c("Diurnal" = "white", "Nocturnal" = "darkgrey")) +
scale_x_discrete(drop = FALSE) +  # This keeps all factor levels even if no data
facet_wrap(~ tideHighLow, ncol = 2) +
labs(x     = "Receiver Deployment",
y     = "Rate of Use (%)",
fill  = "Tide Diel",
shape = "Tide Diel",
title = label_vec[species_name]) +
coord_cartesian(ylim = c(0, 50)) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "bottom")
return(p)
}
# Define the order of recvDeployName once for all plots
recv_deploy_order <- sort(unique(figure_plot$recvDeployName))
# Get unique species names
species_list <- unique(figure_plot$speciesEN)
# Create one plot per species with consistent recv order
plots_used_rate <- purrr::map(species_list, ~ make_plot(.x, recv_order = recv_deploy_order))
# Name the list elements for easy access
names(plots_used_rate) <- species_list
# View individual plots
plots_used_rate[[1]] #PGP
plots_used_rate[[1]]
plots_used_rate[[2]]
plots_used_rate[[3]]
plots_used_rate[[4]]
# Source the script into that environment
source(knitr::purl(here::here("qmd", "chapter_1", "ch1_3.qmd"),
output = tempfile(fileext = ".R"),
quiet = TRUE))
View(color_df)
View(species_df)
# Birds
data_all <- readRDS(
tail(sort(list.files(
here::here("qmd", "chapter_1", "data", "motus"),
pattern = "-data\\.rds$", full.names = TRUE
)), 1))
# Receivers info
recv <- readRDS(
tail(sort(list.files(
here::here("qmd", "chapter_1", "data", "motus"),
pattern = "-recv-info\\.rds$", full.names = TRUE
)), 1))
# Tide
tide_data <- readRDS(here("qmd", "chapter_1", "data", "tides", "tideData.rds"))
library(motus)
library(dplyr)
library(here)
library(forcats)
library(ggplot2)
library(lubridate)
library(tidyr)
library(purrr)
library(readr)
library(bioRad)
library(hms)
library(dplyr)
library(ggplot2)
library(scales)
# Birds
data_all <- readRDS(
tail(sort(list.files(
here::here("qmd", "chapter_1", "data", "motus"),
pattern = "-data\\.rds$", full.names = TRUE
)), 1))
# Receivers info
recv <- readRDS(
tail(sort(list.files(
here::here("qmd", "chapter_1", "data", "motus"),
pattern = "-recv-info\\.rds$", full.names = TRUE
)), 1))
# Tide
tide_data <- readRDS(here("qmd", "chapter_1", "data", "tides", "tideData.rds"))
# Receivers activity
sql.motus <- DBI::dbConnect(RSQLite::SQLite(), here::here("qmd", "chapter_1", "data", "project-294.motus"))
recv.act <- tbl(sql.motus, "activity")  %>%
collect() %>%
as.data.frame() %>%
rename(deviceID = "motusDeviceID") %>%
filter(deviceID %in% unique(recv$deviceID)) %>% # keep our deployed antennas only
# Set the time properly - IMPORTANT
mutate(date = as_datetime(as.POSIXct(hourBin* 3600, origin = "1970-01-06", tz = "UTC")),
dateAus = as_datetime(as.POSIXct(hourBin* 3600, origin = "1970-01-06", tz = "UTC"),
tz = "Australia/Sydney"))
View(data_all)
data_all1 <- data_all
names(data_all)
data_all <- data_all %>%
select(speciesEN, Bird.ID, dateAus, recvDeployName, DateAUS.Trap, tideCategory)
data_all <- data_all %>%
select(speciesEN, Band.ID, dateAus, recvDeployName, DateAUS.Trap, tideCategory)
head(data_all)
summary(data_all)
class(data_all)
library(vegan)
install.packages("vegan")
install.packages("philentropy")
library(vegan)
library(vegan)
library(philentropy)
library(motus)
library(dplyr)
library(here)
library(DBI)
library(RSQLite)
library(forcats)
library(lubridate)
library(bioRad)
library(purrr)
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
Sys.setenv(TZ="UTC")
proj.num <- 294
motusLogout()
sql.motus <- tagme(projRecv = proj.num,
new = FALSE, # TRUE overwrites existing file
update = TRUE,
dir = here("qmd", "chapter_1","data"))
sql.motus <- tagme(projRecv = proj.num,
new = FALSE, # TRUE overwrites existing file
update = TRUE,
dir = here("qmd", "chapter_1","data"))
motusLogout()
sql.motus <- tagme(projRecv = proj.num,
new = FALSE, # TRUE overwrites existing file
update = TRUE,
dir = here("qmd", "chapter_1","data"))
metadata(sql.motus, proj.num)
gc()
# Source the .qmd that set styles and codex into that environment
source(knitr::purl(here::here("qmd", "chapter_1", "ch1_3.qmd"),
output = tempfile(fileext = ".R"),
quiet = TRUE))
################ First, run the .R script to download last up to date Motus data-set
update <- TRUE # Second, Chose whether to update new detections from last data.rds (update = TRUE)
# install.packages("motus",
#                  repos = c(birdscanada = 'https://birdscanada.r-universe.dev',
#                            CRAN = 'https://cloud.r-project.org'))
library(motus)
library(dplyr)
library(here)
library(DBI)
library(RSQLite)
library(forcats)
library(lubridate)
library(bioRad)
library(purrr)
library(ggplot2)
Sys.setenv(TZ="UTC")
proj.num <- 294
sql.motus <- dbConnect(SQLite(), here::here("qmd", "chapter_1", "data", "project-294.motus"))
df.alltags <- tbl(sql.motus, "alltags") %>%
dplyr::collect() %>%
as.data.frame() %>%
mutate(time = as_datetime(ts),
timeAus = as_datetime(ts, tz = "Australia/Sydney"),
dateAus = as_date(timeAus),
year = year(time),
doy = yday(time))
View(df.alltags)
tail(df.alltags %>%
select(timeAus, speciesEN, motusTagID, tagModel, pulseLen, recvDeployName, recv))
library(motus)
library(dplyr)
library(here)
library(DBI)
library(RSQLite)
library(forcats)
library(lubridate)
library(bioRad)
library(purrr)
library(ggplot2)
library(tidyr)
library(gt)
library(gtExtras)
# Birds
data_all <- readRDS(
tail(sort(list.files(
here::here("qmd", "chapter_1", "data", "motus"),
pattern = "-data\\.rds$", full.names = TRUE
)), 1))
# Receivers info
recv <- readRDS(
tail(sort(list.files(
here::here("qmd", "chapter_1", "data", "motus"),
pattern = "-recv-info\\.rds$", full.names = TRUE
)), 1))
# Spreadsheet
spreadsheet <- readRDS(
tail(sort(list.files(
here::here("qmd", "chapter_1", "data", "spreadsheet"),
pattern = "-spreadsheet\\.rds$", full.names = TRUE
)), 1))
View(df.alltags)
View(spreadsheet)
# Band.IDs in spreadsheet but not in data_all (tagged + released but not detected)
nb_undetect <- spreadsheet %>%
filter(is.na(Euthanised.)) %>%
distinct(Band.ID) %>%
filter(!Band.ID %in% unique(data_all$Band.ID))
# Band.IDs in spreadsheet and in data_all (tagged + released and detected)
nb_detect <- spreadsheet %>%
filter(is.na(Euthanised.)) %>%
distinct(Band.ID) %>%
filter(Band.ID %in% unique(data_all$Band.ID))
# Bird released (total tagged and released birds, supposed to be detectable)
nb_release <- spreadsheet %>%
filter(is.na(Euthanised.),
is.na(Retagged.))
# Combine all into Monitoring table table
moni <- bind_rows(
# Nb of birds trapped & tagged
tibble(variable = "nb_tagged",
value  = length(spreadsheet$Band.ID)),
# Nb of birds euthanised (tag re-used)
tibble(variable = "nb_euthanised",
value  = sum(spreadsheet$Euthanised. == "Y", na.rm = TRUE)),
# Nb of birds re-trapped & re-tagged (initial tag lost)
tibble(variable = "nb_retagged",
value  = sum(!is.na(spreadsheet$Retagged.))),
# Nb of birds trapped, tagged & released (supposed to be detectable)
tibble(variable = "nb_released",
value  = nrow(nb_release)),
# Nb of birds released but never detected
tibble(variable = "detect_0",
value  = nrow(nb_undetect)),
# Nb of birds released with low detection (less than 30 times)
tibble(variable = "detect_inf_150",
value  = data_all %>%
count(Band.ID) %>%
filter(n < 150) %>% #1*: we can change this treshold value depending our appreciation
nrow() ),
# Nb of birds released with good detection (more than 30 times)
tibble(variable = "detect_sup_150",
value  = data_all %>%
count(Band.ID) %>%
filter(n > 149) %>% #1*
nrow() )
)
# Undetected, Euthanised & Detected tables
undetect <-  spreadsheet %>%
filter(Band.ID %in% nb_undetect$Band.ID)
eutha <-  spreadsheet %>%
filter(Euthanised.== "Y")
detect <- spreadsheet %>%
filter(Band.ID %in% nb_detect$Band.ID)
retag <- spreadsheet %>%
filter(!is.na(spreadsheet$Retagged.))
View(detect)
unique(data_all$Band.ID)
unique(spreadsheet$Band.ID)
View(data_all)
# Call and extract last up to date Spreadsheet record (sync your one drive with the TEAMS channel first)
tryCatch({
write.csv(
readxl::read_excel("C:/Users/c3541851/The University of Newcastle/StudentGroupPhD - Louise Williams and Mattea Taylor - General/SHOREBIRD NUMBER TRACKING.xlsx"),
file.path(here::here( "qmd", "chapter_1", "data", "spreadsheet"), paste0(Sys.Date(), "-teams.sheet", ".csv")),
row.names = FALSE
)
}, error = function(e) {
write.csv(
readxl::read_excel("C:/Users/marin/The University of Newcastle/StudentGroupPhD - Louise Williams and Mattea Taylor - General/SHOREBIRD NUMBER TRACKING.xlsx"),
file.path(here::here( "qmd", "chapter_1", "data", "spreadsheet"), paste0(Sys.Date(), "-teams.sheet", ".csv")),
row.names = FALSE
)
})
View(spreadsheet)
# Load df with date at the beginning
spreadsheet <- read.csv(here::here( "qmd", "chapter_1", "data", "spreadsheet", paste0(Sys.Date(), "-teams.sheet.csv"))) %>%
# Keep only the tagged ones
filter(Radio.tag. == "Y") %>%
# Variable names
rename(DateAUS.Trap = "Date",
motusTagID = "Motus.tag.ID",
speciesEN = "Species") %>%
# Value names
mutate(speciesEN = case_when(
speciesEN == "Eastern Curlew" ~ "Far Eastern Curlew",
speciesEN == "Black-winged Stilt" ~ "Pied Stilt",
speciesEN == "Pacific Golden Plover" ~ "Pacific Golden-Plover",
speciesEN == "Whimbrel" ~ "Eurasian Whimbrel",
TRUE ~ speciesEN )) %>%
# Format
mutate(motusTagID = as.factor(motusTagID),
DateAUS.Trap = as.Date(DateAUS.Trap) ) %>%
select(Band.ID, motusTagID, speciesEN, DateAUS.Trap, everything())
View(spreadsheet)
View(spreadsheet)
