{
  "hash": "c5ea14cb06382467c7c166631dcc858b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Load & Format\"\n---\n\n::: {.callout style=\"border-left: 6px solid #D99B8F; --bs-callout-border: #D99B8F; padding: 1.5rem; border-radius: 8px; margin-bottom: 1rem;\"}\nOur Motus project aims to better understand movements and habitat preferences for shorebird populations within the local estuaries of the Hunter and Port Stephens. It has a focus on Far Eastern Curlew but additional species are also studied.\n\n-   **Motus Project:** [*Shorebird monitoring in central NSW estuaries*](https://motus.org/dashboard/#e=profile&d=projects&s=294)\n\n-   **Project ID:** *294*\n\n-   **Citation:** *Griffin, A. Shorebird monitoring in central NSW estuaries (Project 294). 2019. Data accessed from Motus Wildlife Tracking System, Birds Canada. Available: https://motus.org/. Accessed: 2025-12-11*\n\nRetrieve the data from Motus server ([Accessing detections data - Motus 2025](https://motuswts.github.io/motus/articles/03-accessing-data.html)) and load them into your R environment so you can filter and format for further analysis.\n\n[This page describes:]{.underline}\n\n-   The filtering procedures (date, individual ID, receiver names, false positive detections, etc.)\n\n-   The implementation of key variables (tidal and circadian cycles, survey effort from receivers)\n:::\n\n## Packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"motus\", \n#                  repos = c(birdscanada = 'https://birdscanada.r-universe.dev',\n#                            CRAN = 'https://cloud.r-project.org'))\nlibrary(motus)\nlibrary(dplyr)\nlibrary(here)\nlibrary(DBI)\nlibrary(RSQLite)\nlibrary(forcats) \nlibrary(lubridate)\nlibrary(bioRad) \nlibrary(purrr) \nlibrary(ggplot2) \n```\n:::\n\n\nYou will need the `motus` package which you can download either online ([Installing packages - Motus 2025](https://motuswts.github.io/motus/articles/02-installing-packages.html)) or from R.\n\n## Download\n\n::: blockquote-yellow\n**Note for authors**:\n\n-   You will have to separately run this [R script](https://uoneduau-my.sharepoint.com/:u:/g/personal/c3541851_uon_edu_au/IQCkznVmqu5NR7E5_EvqJvghAQ4ZM9-jLjCfcw73EtJDfBE?e=gxO5Y7) that will follow the two next chunks before to continue. Indeed, \\`tagme( )\\` will prompt and require *username* and *password* that can't be fed here.\n\n-   Run this script to update database only. The procedure is heavy and takes a while to complete (up to 45 min).\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Global settings\nsetwd(dirname(rstudioapi::getSourceEditorContext()$path)) \nSys.setenv(TZ=\"UTC\") \nproj.num <- 294  \nmotusLogout()\n```\n:::\n\n\nFirst, set general settings as working directory, Time Zone and Motus project number.\n\nThen, make sure the environment is free from any connection to any other networked project to avoid undesired mistakes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsql.motus <- tagme(projRecv = proj.num,\n                   new = FALSE, # TRUE overwrites existing file\n                   update = TRUE,\n                   dir = here(\"qmd\", \"chapter_1\",\"data\"))\n\nmetadata(sql.motus, proj.num)\n\nsql.motus <- dbConnect(SQLite(), here::here(\"qmd\", \"chapter_1\", \"data\", \"project-294.motus\"))\n\ndf.alltags <- tbl(sql.motus, \"alltags\") %>%\n  dplyr::collect() %>%\n  as.data.frame() %>%\n    mutate(time = as_datetime(ts),\n         timeAus = as_datetime(ts, tz = \"Australia/Sydney\"),\n         dateAus = as_date(timeAus),\n         year = year(time), \n         doy = yday(time))\n```\n:::\n\n\nRetrieve the data from Motus server to access them in a data-frame format.\n\n\n::: {.cell}\n\n:::\n\n\n`motus::tagme()`gets the data from the online Motus network, the ones part of your project (ie. ID = 294) only. Make sure you set your own directory. A file of type .sql is automatically created.\n\nIf you already have a .sql file, set `new` = FALSE and `update` = TRUE so you are updating your existing file instead of re-downloading the full thing, which can take a while.\n\n`motus::metadata()` downloads the metadata from the online Motus network (receiver information and more).\n\n`motus::dbConnect()` links your .sql to your environment. Avoid to use high memory as .sql is a *lazy* table and not yet hardly written on your hardware.\n\n`motus::tbl()` extracts all the tags fat into your environment. Then formatted into a classic dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntail(df.alltags %>% \n       select(timeAus, speciesEN, motusTagID, tagModel, pulseLen, recvDeployName, recv))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                    timeAus        speciesEN motusTagID    tagModel pulseLen\n2962188 2025-12-17 04:10:40 Curlew Sandpiper      99026 NTQB2-4-2-M      2.5\n2962189 2025-12-17 04:11:06 Curlew Sandpiper      99026 NTQB2-4-2-M      2.5\n2962190 2025-12-17 04:28:53 Curlew Sandpiper      99025 NTQB2-4-2-M      2.5\n2962191 2025-12-17 04:29:20 Curlew Sandpiper      99025 NTQB2-4-2-M      2.5\n2962192 2025-12-17 04:29:33 Curlew Sandpiper      99025 NTQB2-4-2-M      2.5\n2962193 2025-12-17 04:29:59 Curlew Sandpiper      99025 NTQB2-4-2-M      2.5\n               recvDeployName            recv\n2962188 Ramsar Road Floodgate SG-E3E4RPI4CED5\n2962189 Ramsar Road Floodgate SG-E3E4RPI4CED5\n2962190 Ramsar Road Floodgate SG-E3E4RPI4CED5\n2962191 Ramsar Road Floodgate SG-E3E4RPI4CED5\n2962192 Ramsar Road Floodgate SG-E3E4RPI4CED5\n2962193 Ramsar Road Floodgate SG-E3E4RPI4CED5\n```\n\n\n:::\n:::\n\n\nAbove, a quick view about the last data uploaded to Motus server, giving you the latest detection taken into account for this workflow.\n\n## Filter\n\n### TAGS\n\n::: blockquote-red\n**WARNING**: The values entered within the below filtering R code are depending your own context.\n:::\n\nHere are cleaned-out the data recorded from undesired tags and/or receivers depending our local context. So the following has been processed on the raw data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cleaning and correcting tags metadata\ndf.alltags <- df.alltags %>% \n   filter(\n    # test tags\n     motusTagID != c(\"43291\"),\n    # pending, unconfirmed or undeployed tags\n    !motusTagID %in% c(\"43288\", \"43291\", \"43297\", \"43299\",\n                       \"43307\", \"43424\", \"43425\", \"60470\", \n                       \"60579\", \"81123\", \"81136\", \"81137\"),\n    # used for test/validation before tagging bird (remove time before the tagging)\n    !(motusTagID == \"81134\" & time < dmy(\"23-11-2024\")),\n    !(motusTagID == \"60575\" & time < dmy(\"25-10-2023\")) ) %>% \n    # NA species\n     mutate(speciesEN = case_when(\n       is.na(speciesEN) & motusTagID %in% c(\"60470\", \"81121\") ~ \"Red-necked Avocet\",\n       is.na(speciesEN) & motusTagID %in% c(\"81118\") ~ \"Red-necked Avocet\",\n       TRUE ~ speciesEN)) %>%\n  \n  # motusTagID as factor\n  mutate(motusTagID = as.factor(motusTagID))\n\n  \n# Cleaning and correcting receiver metadata\ndf.alltags <- df.alltags %>% \n  filter(\n    # NA\n     !is.na(recvDeployLat),\n    # site not any longer used\n      recvDeployName != c(\"Throsby Creek Test Site\"),\n    # test sensor gnome\n      recv != c(\"SG-C621RPI3E17F\",       \n                \"SG-62A5RPI36710\") ) %>% \n    # Windeyers\n  mutate(recvDeployName = ifelse(is.na(recvDeployName) & recv == \"SG-D5BBRPI3E2F7\",\n                                 \"Windeyers\", \n                                 recvDeployName))\n```\n:::\n\n\n**Have been removed:**\n\n-   Test tags\n\n-   Tags recorded into the Motus project but undeployed;\n\n-   Period of time where tags were *ON* but not set on any bird;\n\n-   Test SensorGnome;\n\n-   Sites not any longer used.\n\n**Have been modified:**\n\n-   Tag's `specieEN` information have been changed from *NA* to different values depending case to case;\n\n-   Receiver station's name `recvDeployName` has been changed from *NA* to Windeyers starting from 02/15/2025.\n\n**False positive:**\n\nLet's now visualise the quality of our data in term of **False Positive** and likely wrong detection because of a too low **Run** **Length**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Checking 'motusFiltered in' tag data\nggplot(df.alltags %>%\n         filter(motusFilter == 1),\n       aes(x = recvDeployName)) +\n  geom_bar(fill = \"steelblue\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  labs(x = \"Motus Station\", y = \"Nb of motusFilter = 1 (good)\") \n```\n\n::: {.cell-output-display}\n![](ch1_1_files/figure-html/2 filter the noise plot things-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Checking 'motusFiltered out' tag data\nggplot(df.alltags %>%\n         filter(motusFilter == 0),\n       aes(x = recvDeployName)) +\n  geom_bar(fill = \"orange\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  labs(x = \"Motus Station\", y = \"Nb of motusFilter = 0 (filtered out)\")\n```\n\n::: {.cell-output-display}\n![](ch1_1_files/figure-html/2 filter the noise plot things-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# Checking proportion of data quality for each station\nperc <- ggplot(df.alltags %>% \n                 filter(motusFilter %in% c(0, 1)),\n       aes(x = recvDeployName, fill = factor(motusFilter))) +\n  geom_bar(position = \"fill\") + \n  scale_fill_manual(values = c(\"0\" = \"orange\",\n                               \"1\" = \"steelblue\"),\n                    labels = c(\"0 (filtered out)\", \n                               \"1 (good)\"),\n                    name = \"motusFilter\") +\n  theme_minimal() +\n  labs(x = \"Motus Station\",\n       y = \"Proportion\") +\n  scale_y_continuous(labels = scales::percent) +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n# ggpubr::ggexport(perc,\n#                  filename = here(\"figures\", \"motus_filter_perc.jpg\"),\n#                  width = 800, height = 1000)\n\nperc\n```\n\n::: {.cell-output-display}\n![](ch1_1_files/figure-html/2 filter the noise plot things-3.png){width=672}\n:::\n:::\n\n\nFind in the above table the distribution of the data depending their quality and for each station.\n\n[Blue]{style=\"color: steelblue;\"} values are detections considered as **True Positive** from Motus and [orange]{style=\"color: orange;\"} values as **False Positive.**\n\nIndeed, a Motus station might have an interfering noisy radio environment within its vicinity (power line, flight corridor, road proximity, etc.).\n\nBeing able to flag an abnormal amount of False Positive for one station might be useful at assuming the data are True Positive but considered False Positive because of too much radio noise around.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# False positive\ndf.alltags <- df.alltags %>% \n  filter(motusFilter == 1, # 0 is invalid data\n         runLen >= 3) # value to be further thought\n```\n:::\n\n\nThe **False Positive** signals are filtered out (i.e. noise coming from external device, or any kind of external radio activity happening within the area) thanks to the pre-made \\`motusFilter\\` and the \\`runLen\\`.\n\n-   **Motus Filter threshold values is set at 1**, based on [Motus documentation](https://motuswts.github.io/motus/articles/05-data-cleaning.html)and our data (see below).\n\n-   **Run Length threshold value is set at 3** and defines the number of bursts recorded from one tag and received at once: too low amount of bursts are suspected to not be True Positive, therefore not reliable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ambiguous  \nclarify(sql.motus) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] ambigID    numHits    id1        fullID1    id2        fullID2   \n [7] id3        fullID3    id4        fullID4    id5        fullID5   \n[13] id6        fullID6    motusTagID tsStart    tsEnd     \n<0 rows> (or 0-length row.names)\n```\n\n\n:::\n:::\n\n\n`motus::clarify()` checks whether the combination of two tag signals emitting at the mean time could generate the single detection of a third *not-existing* tag signal, which would also be a False Positive, but also hiding two True Positives. If the table generated by this code has rows resulting, please go to [Motus documentation](https://motuswts.github.io/motus/articles/05-data-cleaning.html). A table is generated as an output and each rows correspond a case. A table with zero row means none of such a case occurred, so your data are clean.\n\n### SENSORGNOME\n\n**Receivers** data and their meta-information must be filtered and formatted as well.\n\nIndeed, s[ome receivers might have been swap within the Motus array and along time]{.underline}, therefore the same SensorGnome ID might be used by multiple stations along time, leading to wrong results.\n\n::: blockquote-yellow\n**IMPORTANT**: Make sure you tracked the history of your receivers to avoid misled results.\n:::\n\nHere, we only need to rename the stations accurately and to remove those that are not used any longer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get summary \ndf.recvDeps <- tbl(sql.motus, \"recvDeps\") %>%   \n  collect() %>%   \n  as.data.frame() %>%    \n  mutate(timeStart = as_datetime(tsStart),\n         timeStartAus = as_datetime(tsStart, tz = \"Australia/Sydney\"), \n         timeEnd = as_datetime(tsEnd),\n         timeEndAus = as_datetime(tsEnd, tz = \"Australia/Sydney\"))  \n\n# Rename stations across alltags & receiver data-sets \nstation_rename <- list(\"Barry_Fullerton_cove\"  = \"Fullerton Entrance\", \n                       \"North Swann Pond\" = \"Swan Pond\" ,\n                       \"Ramsar Road Floodgate\" = \"Ramsar Road\",   \n                       \"Milham's Pond\" = \"Milhams Pond\") \n\ndf.recvDeps <- df.recvDeps %>%\n  mutate(name = recode(name, !!!station_rename))\n\ndf.alltags <- df.alltags %>% mutate(name = recode(recvDeployName,\n                                                            !!!station_rename)) \n\n# Filter not used stations as out of the local array \ndf.recvDeps <- df.recvDeps %>% \n  filter(!is.na(latitude),   \n         name != c(\"Throsby Creek Test Site\"),    \n         serno != c(\"SG-C621RPI3E17F\",   # test station\n                    \"SG-62A5RPI36710\") ) # test station\n```\n:::\n\n\n## Survey time frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf.recvDeps <- df.recvDeps %>%   filter(timeStartAus > \"2023-01-31 00:00:00 AEDT\")\n```\n:::\n\n\nFinally, we need to set temporal aspect of the *survey effort.*\n\nDay one for our local Motus array to start *listening* any tag signals is set on the **31st January 2023** - one month before the first day a bird has been caught and tagged (information found into the [SharePoint](https://uonstaff.sharepoint.com/:x:/r/sites/StudentGroupPhD-LouiseWilliamsandMatteaTaylor/_layouts/15/Doc2.aspx?action=edit&sourcedoc=%7Ba23e66f0-c551-4ba4-acd0-de0d5e83ca42%7D&wdOrigin=TEAMS-MAGLEV.teamsSdk_ns.rwc&wdExp=TEAMS-TREATMENT&wdhostclicktime=175385) to access the file.).\n\n## Import band ID\n\nAs we might re-trap individuals and re-tag them with a new MOTUS tag, we can't use the Motus tag ID as unique ID anymore and have to use Band ID which supposes to last on the same bird from banding date to individual's death. Unfortunately, the Band ID is not imported by MOTUS network at the moment. So, we need to import it from our own record accessible on SharePoint [here](https://uonstaff.sharepoint.com/:x:/r/sites/StudentGroupPhD-LouiseWilliamsandMatteaTaylor/Shared%20Documents/General/SHOREBIRD%20NUMBER%20TRACKING.xlsx?d=wa23e66f0c5514ba4acd0de0d5e83ca42&csf=1&web=1&e=BuGI0w&nav=MTVfe0QyREY1NzZGLUM2RjktNEJFRi1BQThGLTc1M0E3OEFFM0ZERn0), download the .*csv*.\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load df with date at the beginning \nspreadsheet <- read.csv(here::here( \"qmd\", \"chapter_1\", \"data\", \"spreadsheet\", paste0(Sys.Date(), \"-teams.sheet.csv\"))) %>%   \n  \n  # Keep only the tagged ones \n  filter(Radio.tag. == \"Y\") %>%      \n  \n  # Variable names\n  rename(DateAUS.Trap = \"Date\", \n         motusTagID = \"Motus.tag.ID\", \n         speciesEN = \"Species\") %>%\n  \n  # Value names\n  mutate(speciesEN = case_when(\n    speciesEN == \"Eastern Curlew\" ~ \"Far Eastern Curlew\",\n    speciesEN == \"Black-winged Stilt\" ~ \"Pied Stilt\",\n    speciesEN == \"Pacific Golden Plover\" ~ \"Pacific Golden-Plover\",\n    speciesEN == \"Whimbrel\" ~ \"Eurasian Whimbrel\",\n    TRUE ~ speciesEN )) %>% \n  \n  # Format\n  mutate(motusTagID = as.factor(motusTagID),\n         DateAUS.Trap = as.Date(DateAUS.Trap) ) %>%\n  select(Band.ID, motusTagID, speciesEN, DateAUS.Trap, everything())  \n\n# Join unique Band IDs for inconsistent motusTag (same bird re-tagged, etc) \ndf.alltags <- left_join(df.alltags, spreadsheet %>%    \n                        filter(is.na(Euthanised.)) %>%  \n                        select(motusTagID, DateAUS.Trap, Band.ID, Bander), \n                      by = \"motusTagID\")\n```\n:::\n\n\nSo we merged our records with Band ID for each bird to the Motus data, linked with the Motus tag ID. Allowing unique individual IDs.\n\n## Add key variables\n\nIt is crucial for our further analysis to add the **Tidal and Circadian cycles** as variables so we can match each bird detection with a categorical value for a date, a tide (high/low) and a period of the day (night/day).\n\nTo do so, we must first fetch the tide data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read tide.csv\ntideData <- read.csv(here(\"qmd\", \"chapter_1\", \"data\", \"tides\", \"TideDataNewcastle.csv\"))\n\n# Format date and datetime columns\ntideData$tideDateTimeAus <- ymd_hms(tideData$tideDateTime, tz = \"Australia/Sydney\")\ntideData <- tideData %>% mutate(\n  date = as.POSIXct(date, format = \"%d/%m/%Y\", tz = \"Australia/Sydney\"))\n\n# Classify tides as diurnal or nocturnal\ntideData <- tideData %>% mutate(\n  sunriseNewc = sunrise(date, 151.7833, -32.9167, elev = -0.268, tz = \"Australia/Sydney\", force_tz = TRUE),\n  sunsetNewc = sunset(date, 151.7833, -32.9167, elev = -0.268, tz = \"Australia/Sydney\", force_tz = TRUE),\n  sunriseNewcTime = strftime(sunriseNewc, format = \"%H:%M:%S\", tz = \"Australia/Sydney\"),\n  sunsetNewcTime = strftime(sunsetNewc, format = \"%H:%M:%S\", tz = \"Australia/Sydney\"))\n\n# Define either diurnal or nocturnal \ntideData <- tideData %>% mutate(\n  day_night = case_when(\n    tideDateTimeAus < sunriseNewc ~ \"Nocturnal\",\n    tideDateTimeAus > sunriseNewc & tideDateTimeAus < sunsetNewc ~ \"Diurnal\",\n    tideDateTimeAus > sunsetNewc ~ \"Nocturnal\"))\n\n# Categorise each tide by tidal/diel period\ntideData <- tideData %>% mutate(  \n    tideCategory = case_when(\n      high_low == \"Low\" & day_night == \"Diurnal\" ~ \"Diurnal_Low\",\n      high_low == \"Low\" & day_night == \"Nocturnal\" ~ \"Nocturnal_Low\",\n      high_low == \"High\" & day_night == \"Diurnal\" ~ \"Diurnal_High\",\n      high_low == \"High\" & day_night == \"Nocturnal\" ~ \"Nocturnal_High\") %>% \n      as_factor())\n\n# Add numeric ID to each category, allowing for unique tide bins\ntideData <- tideData %>%\n  group_by(tideCategory) %>% \n  mutate(tideID = paste0(tideCategory, \"_\", row_number())) %>% \n  ungroup()\n```\n:::\n\n\nNote that tide data-set must be extracted from [New South Wales government resources](https://www.nsw.gov.au/driving-boating-and-transport/using-waterways-boating-and-transport-information/conditions-weather-and-tides/nsw-tide-tables) and formatted into a .csv file - made for you and directly accessible [here](https://uoneduau-my.sharepoint.com/:x:/g/personal/c3541851_uon_edu_au/IQBIG1rLs3tZT4oH64iNlp-UAX_G5teXcB5f76Uc7Aoe8hs?e=Znl4jf).\n\nAll the **Tide** categories are set for a unique point in Newcastle, easing the complexity of small scale differences for the tide within the estuary.\n\n**Let's now add our key variables for each bird detection:**\n\n-   Signal strength\n\n-   Circadian period\n\n-   Tidal period\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load useful functions from Callum Gapes work\ntidalCurve <- readRDS(here::here(\"qmd\", \"chapter_1\", \"data\", \"tides\", \"tidalCurve.rds\"))\ntidalCurveFunc <- splinefun(tideData$tideDateTimeAus, tideData$tideHeight, method = \"natural\")\nget.tideIndex <- function(time){ return(which.min(abs(tideData$tideDateTimeAus-time)))}\n\n# Add key variables\ndf.alltags <- df.alltags  %>%\n  \n  # Positive signal strength (min. = 0) for plotting\n  mutate(sigPositive = sig + abs(min(sig))) %>% \n  \n  # Sunrise/set\n  sunRiseSet(lat = \"recvDeployLat\", \n             lon = \"recvDeployLon\", \n             ts = \"ts\") %>% \n  mutate(sunriseNewc = sunrise(dateAus, 151.7833, -32.9167, elev = -0.268, tz = \"Australia/Sydney\", force_tz = TRUE),\n         sunsetNewc = sunset(dateAus, 151.7833, -32.9167, elev = -0.268, tz = \"Australia/Sydney\", force_tz = TRUE)) %>%\n\n  # Tide\n  mutate(tideHeight = tidalCurveFunc(timeAus),\n         tideIndex = map_dbl(timeAus, get.tideIndex))\n\n  tide_values <- tideData[df.alltags$tideIndex, \n                        c(\"tideDateTimeAus\",\n                          \"high_low\",\n                          \"day_night\",\n                          \"tideCategory\",\n                          \"tideID\",\n                          \"tideHeight\")]\n\n# Factorise the variables\ndf.alltags <- df.alltags %>%\n  mutate(tideDateTimeAus = tide_values$tideDateTimeAus,\n         tideHighLow = as_factor(tide_values$high_low),\n         tideDiel = as_factor(tide_values$day_night),\n         tideCategory = as_factor(tide_values$tideCategory),\n         tideCategoryHeight = tide_values$tideHeight,\n         tideID = as_factor(tide_values$tideID),\n         tideTimeDiff = abs(difftime(timeAus, tideDateTimeAus, units = \"hours\")))\n```\n:::\n\n\n## Save\n\n::: blockquote-yellow\n**Note for authors**:\n\nSome observations (**n = 4**) in the detections data retrieved from Motus server do hold *NA* values for `speciesEN`.\n\nAs long as we consider it is negligible, these observations are removed.\n:::\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n              timeAus speciesEN Band.ID markerNumber motusTagID    tagModel\n1 2025-11-04 17:24:53      <NA>      NA         <NA>      98916 NTQB2-6-1-M\n2 2025-11-04 17:25:45      <NA>      NA         <NA>      98916 NTQB2-6-1-M\n3 2025-11-04 17:26:12      <NA>      NA         <NA>      98916 NTQB2-6-1-M\n4 2025-11-04 17:27:04      <NA>      NA         <NA>      98916 NTQB2-6-1-M\n  pulseLen recvDeployName            recv\n1      2.5   Curlew Point SG-61F1RPI3C8AB\n2      2.5   Curlew Point SG-61F1RPI3C8AB\n3      2.5   Curlew Point SG-61F1RPI3C8AB\n4      2.5   Curlew Point SG-61F1RPI3C8AB\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Bird detection dqtq\nsaveRDS(df.alltags, here::here(\"qmd\", \"chapter_1\", \"data\", \"motus\", paste0(Sys.Date(), \"-data\", \".rds\" )))\n\n# Receiver information\nsaveRDS(df.recvDeps, here::here(\"qmd\", \"chapter_1\", \"data\", \"motus\", paste0(Sys.Date(), \"-recv-info\", \".rds\" )))\n\n# Spreadsheet tracking BandID\nsaveRDS(spreadsheet, here::here(\"qmd\", \"chapter_1\", \"data\", \"spreadsheet\", paste0(Sys.Date(), \"-spreadsheet\", \".rds\" )))\n\n# Tide tables\nsaveRDS(tideData, here(\"qmd\", \"chapter_1\", \"data\", \"tides\", \"tideData.rds\"))\n```\n:::\n\n\nSave your formatted data, now ready for analysis!\n",
    "supporting": [
      "ch1_1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}